With only base as anchors, the number of anchor poses is 100x (frag10) to 250x (frag6)
as large.
For now, at frag7 and frag9, only select 5 % (1/20) poses at random + the nearest-bound  pose.

For frag7, keeping the best global-fit conformer for the best roco-fit conformer
greatly improves the filtering, now we would keep 20 x 20.1k poses = 400k poses,
whereas for test4 it is 300k (despite 250x less anchors).
Unfortunately, it would take like 7h on my full laptop to compute all 400k poses.

For frag9, it is much worse. Instead of 628 poses, there are now 20x 9763 = ~200k.
A factor 300 increase is more than we can handle, when growing the poses.

Growing the poses:
Each conformer has ~13k rotamers
Per conformer:
    Initial fit on ~200 rotamer clusters costs almost no time.
    This gives ~1500 rotamer candidates, fitting on this takes 10ms.
    Which is too slow, since there can 750 or more conformers to consider, i.e. 7+ seconds per pose.
    After that, there can be up to a few dozen final rotamers, for which offsets have to be found
    This is not insignificant (maybe 2ms per conformer), but it can be optimized later.
        With the current speed it is a few thousand final poses per second.

Plan: reduce rotamer identification by at least an order of magnitude, preferably two orders.
Detailed plan:
Quaternion discretization succeeded, see nucleotide-repositories/make-rotaconformers/discrete-quaternions.py.
To do: sample 25**3=16k evenly spaced quaternions. For each conformer, store the 5 closest rotamers,
i.e. 160 KB per conformer = 1 GB per library. 
Also, for each rotamer, store the 5 closest other rotamers (about 130 KB per conformer, 800 MB per library).
Initially, calculate the overlap RMSD for the 5 closest and mark them as active.
Add the neighbours of the active rotamers, marking each neighbour with the lowest RMSD of any active rotamer neighbour.
Calculate the RMSD. Only those whose RMSD has gone down are marked as active. 